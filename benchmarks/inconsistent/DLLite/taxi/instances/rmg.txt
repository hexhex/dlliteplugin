 1 RMG: Repair model generator is instantiated for a non-disjunctive component
 1 RMG: after parsing the liberal safety option
 1 RMG: evaluating guessing program
 1 RMG: before calling learnSupportSets method
 1 RMG: learning support sets is started
 1 RMG: Number of all eatoms: 1
 1 RMG: consider atom &cDL["simple.owl",cp,cn,rp,rn,"A"](X)
 1 RMG: evaluating external atom &cDL["simple.owl",cp,cn,rp,rn,"A"](X) for support set learning
 1 RMG: number of learnt support sets: 2
 1 RMG: checking support set { aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), aux_o_0_0("A",O) }
 1 RMG: checking literal aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O)
 1 RMG: checking literal aux_o_0_0("A",O)
 1 RMG: There are no ordinary atoms in support set 
 1 RMG: RULE: (bar_aux_o(C,X)):-aux_o(C,X), n_e_a(Q,O). 
 1 RMG: Check whether there any reasons for not deleting A
 1 RMG: the predicate A is in 
 1 RMG: the ontology predicate "A" is allowed for deletion
 1 RMG: RULE: bar_aux_o(C,X):-aux_o(C,X), n_e_a(Q,O). 
 1 RMG: RULE: Adding rule: aux_o_0_1("A",O) :- aux_o_0_0("A",O), aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: RULE: supp_e_a(Q,O):-aux_o(C,X),e_a(Q,O), not bar_aux_o(C,X).
 1 RMG: RULE: Adding rule: aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O) :- aux_o_0_0("A",O), aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_0_1("A",O).
 1 RMG: RULE: :-e_a(Q,O),not supp_e_a(Q,O).
 1 RMG: RULE: Adding rule: :- aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: checking support set { aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), aux_o_0_0("C",O) }
 1 RMG: checking literal aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O)
 1 RMG: checking literal aux_o_0_0("C",O)
 1 RMG: There are no ordinary atoms in support set 
 1 RMG: RULE: (bar_aux_o(C,X)):-aux_o(C,X), n_e_a(Q,O). 
 1 RMG: Check whether there any reasons for not deleting C
 1 RMG: the predicate C is in 
 1 RMG: the ontology predicate "C" is allowed for deletion
 1 RMG: RULE: bar_aux_o(C,X):-aux_o(C,X), n_e_a(Q,O). 
 1 RMG: RULE: Adding rule: aux_o_0_1("C",O) :- aux_o_0_0("C",O), aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: RULE: supp_e_a(Q,O):-aux_o(C,X),e_a(Q,O), not bar_aux_o(C,X).
 1 RMG: RULE: Adding rule: aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O) :- aux_o_0_0("C",O), aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_0_1("C",O).
 1 RMG: RULE: :-e_a(Q,O),not supp_e_a(Q,O).
 1 RMG: RULE: Adding rule: :- aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: Adding Abox
 1 RMG: Program edb after adding ABox {c("a"),aux_o_0_0("A","a"),aux_o_0_0("C","a"),aux_o_0_0("D","a")}
 1 RMG: program idb: 
 1 RMG: :- aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",X), c(X).
 1 RMG: aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",X) v aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",X) :- c(X).
 1 RMG: aux_o_0_1("A",O) :- aux_o_0_0("A",O), aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O) :- aux_o_0_0("A",O), aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_0_1("A",O).
 1 RMG: :- aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: aux_o_0_1("C",O) :- aux_o_0_0("C",O), aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O) :- aux_o_0_0("C",O), aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_0_1("C",O).
 1 RMG: :- aux_r_10000000_e("simple.owl",cp,cn,rp,rn,"A",O), not aux_o_6000000_0("simple.owl",cp,cn,rp,rn,"A",O).
 1 RMG: after grounding
 1 RMG: annotated ground program is constructed
 1 RMG: after creating a nogood grounder
 1 RMG: RepairModelGenerator constructor is finished
 1 RMG: asking for next model
 1 RMG: Statistics:
 1 gM RMG: got guess model {c("a"),aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A","a"),aux_o_0_0("A","a"),aux_o_0_0("C","a"),aux_o_0_0("D","a"),aux_o_0_1("A","a"),aux_o_0_1("C","a")}
 1 gM RMG: PC: evaluation post check is started:
 1 gM RMG: PC: current model candidate is: {c("a"),aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A","a"),aux_o_0_0("A","a"),aux_o_0_0("C","a"),aux_o_0_0("D","a"),aux_o_0_1("A","a"),aux_o_0_1("C","a")}
 1 gM RMG: PC: final ABox is
 1 gM RMG: final AB: aux_o_0_0("D","a")
 1 gM RMG: PC: going through facts of the current model candidate: 
 1 gM RMG: PC: if aux_e_0_0 is present in the model then the corresponding external atom needs to be evaluated
 1 gM RMG: PC: current atoms is: c("a") with tuple c
 1 gM RMG: PC: current atoms is: aux_n_10000000_e("simple.owl",cp,cn,rp,rn,"A","a") with tuple aux_n_10000000_e
 1 gM RMG: PC: current atoms is: aux_o_0_0("A","a") with tuple aux_o_0_0
 1 gM RMG: PC: current atoms is: aux_o_0_0("C","a") with tuple aux_o_0_0
 1 gM RMG: PC: current atoms is: aux_o_0_0("D","a") with tuple aux_o_0_0
 1 gM RMG: PC: current atoms is: aux_o_0_1("A","a") with tuple aux_o_0_1
 1 gM RMG: PC: current atoms is: aux_o_0_1("C","a") with tuple aux_o_0_1
 1 gM EL: RMG: PC: postcheck is finished
 1 RMG: asking for next model
 1 RMG: Statistics:
 1 RMG: unsatisfiable -> returning no model
